// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: monitor-query.sql

package storage

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countActiveMonitorsByUser = `-- name: CountActiveMonitorsByUser :one
SELECT COUNT(*) FROM monitors WHERE user_id = $1 AND status = 'active'
`

func (q *Queries) CountActiveMonitorsByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countActiveMonitorsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countFailedMonitorChecks = `-- name: CountFailedMonitorChecks :one
SELECT COUNT(*) FROM monitor_checks WHERE monitor_id = $1 AND status = 'failed'
`

func (q *Queries) CountFailedMonitorChecks(ctx context.Context, monitorID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countFailedMonitorChecks, monitorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMonitorChecks = `-- name: CountMonitorChecks :one
SELECT COUNT(*) FROM monitor_checks WHERE monitor_id = $1
`

func (q *Queries) CountMonitorChecks(ctx context.Context, monitorID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMonitorChecks, monitorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMonitorsByUser = `-- name: CountMonitorsByUser :one
SELECT COUNT(*) FROM monitors WHERE user_id = $1
`

func (q *Queries) CountMonitorsByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countMonitorsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSuccessfulMonitorChecks = `-- name: CountSuccessfulMonitorChecks :one
SELECT COUNT(*) FROM monitor_checks WHERE monitor_id = $1 AND status = 'success'
`

func (q *Queries) CountSuccessfulMonitorChecks(ctx context.Context, monitorID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countSuccessfulMonitorChecks, monitorID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMonitor = `-- name: CreateMonitor :one
INSERT INTO monitors (
    user_id,
    name,
    url,
    method,
    interval_seconds,
    timeout_seconds,
    status,
    headers,
    body,
    expected_status_code
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
`

type CreateMonitorParams struct {
	UserID             int32       `json:"user_id"`
	Name               string      `json:"name"`
	Url                string      `json:"url"`
	Method             string      `json:"method"`
	IntervalSeconds    int32       `json:"interval_seconds"`
	TimeoutSeconds     int32       `json:"timeout_seconds"`
	Status             string      `json:"status"`
	Headers            []byte      `json:"headers"`
	Body               pgtype.Text `json:"body"`
	ExpectedStatusCode pgtype.Int4 `json:"expected_status_code"`
}

func (q *Queries) CreateMonitor(ctx context.Context, arg CreateMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, createMonitor,
		arg.UserID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.IntervalSeconds,
		arg.TimeoutSeconds,
		arg.Status,
		arg.Headers,
		arg.Body,
		arg.ExpectedStatusCode,
	)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.IntervalSeconds,
		&i.TimeoutSeconds,
		&i.Status,
		&i.Headers,
		&i.Body,
		&i.ExpectedStatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMonitorCheck = `-- name: CreateMonitorCheck :one
INSERT INTO monitor_checks (
    monitor_id,
    status,
    response_time_ms,
    status_code,
    error_message
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
`

type CreateMonitorCheckParams struct {
	MonitorID      int32       `json:"monitor_id"`
	Status         string      `json:"status"`
	ResponseTimeMs pgtype.Int4 `json:"response_time_ms"`
	StatusCode     pgtype.Int4 `json:"status_code"`
	ErrorMessage   pgtype.Text `json:"error_message"`
}

func (q *Queries) CreateMonitorCheck(ctx context.Context, arg CreateMonitorCheckParams) (MonitorCheck, error) {
	row := q.db.QueryRow(ctx, createMonitorCheck,
		arg.MonitorID,
		arg.Status,
		arg.ResponseTimeMs,
		arg.StatusCode,
		arg.ErrorMessage,
	)
	var i MonitorCheck
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Status,
		&i.ResponseTimeMs,
		&i.StatusCode,
		&i.ErrorMessage,
		&i.CheckedAt,
	)
	return i, err
}

const deleteMonitor = `-- name: DeleteMonitor :exec
DELETE FROM monitors
WHERE id = $1 AND user_id = $2
`

type DeleteMonitorParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) DeleteMonitor(ctx context.Context, arg DeleteMonitorParams) error {
	_, err := q.db.Exec(ctx, deleteMonitor, arg.ID, arg.UserID)
	return err
}

const deleteMonitorByID = `-- name: DeleteMonitorByID :exec
DELETE FROM monitors
WHERE id = $1
`

func (q *Queries) DeleteMonitorByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMonitorByID, id)
	return err
}

const deleteMonitorCheck = `-- name: DeleteMonitorCheck :exec
DELETE FROM monitor_checks
WHERE id = $1
`

func (q *Queries) DeleteMonitorCheck(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteMonitorCheck, id)
	return err
}

const deleteMonitorChecksByMonitorID = `-- name: DeleteMonitorChecksByMonitorID :exec
DELETE FROM monitor_checks
WHERE monitor_id = $1
`

func (q *Queries) DeleteMonitorChecksByMonitorID(ctx context.Context, monitorID int32) error {
	_, err := q.db.Exec(ctx, deleteMonitorChecksByMonitorID, monitorID)
	return err
}

const deleteOldMonitorChecks = `-- name: DeleteOldMonitorChecks :exec
DELETE FROM monitor_checks
WHERE checked_at < $1
`

func (q *Queries) DeleteOldMonitorChecks(ctx context.Context, checkedAt pgtype.Timestamp) error {
	_, err := q.db.Exec(ctx, deleteOldMonitorChecks, checkedAt)
	return err
}

const getAverageResponseTime = `-- name: GetAverageResponseTime :one
SELECT AVG(response_time_ms) as avg_response_time
FROM monitor_checks
WHERE monitor_id = $1 AND response_time_ms IS NOT NULL
`

func (q *Queries) GetAverageResponseTime(ctx context.Context, monitorID int32) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageResponseTime, monitorID)
	var avg_response_time float64
	err := row.Scan(&avg_response_time)
	return avg_response_time, err
}

const getAverageResponseTimeByDateRange = `-- name: GetAverageResponseTimeByDateRange :one
SELECT AVG(response_time_ms) as avg_response_time
FROM monitor_checks
WHERE monitor_id = $1
    AND response_time_ms IS NOT NULL
    AND checked_at >= $2
    AND checked_at <= $3
`

type GetAverageResponseTimeByDateRangeParams struct {
	MonitorID   int32            `json:"monitor_id"`
	CheckedAt   pgtype.Timestamp `json:"checked_at"`
	CheckedAt_2 pgtype.Timestamp `json:"checked_at_2"`
}

func (q *Queries) GetAverageResponseTimeByDateRange(ctx context.Context, arg GetAverageResponseTimeByDateRangeParams) (float64, error) {
	row := q.db.QueryRow(ctx, getAverageResponseTimeByDateRange, arg.MonitorID, arg.CheckedAt, arg.CheckedAt_2)
	var avg_response_time float64
	err := row.Scan(&avg_response_time)
	return avg_response_time, err
}

const getLatestMonitorCheck = `-- name: GetLatestMonitorCheck :one
SELECT id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
FROM monitor_checks
WHERE monitor_id = $1
ORDER BY checked_at DESC
LIMIT 1
`

func (q *Queries) GetLatestMonitorCheck(ctx context.Context, monitorID int32) (MonitorCheck, error) {
	row := q.db.QueryRow(ctx, getLatestMonitorCheck, monitorID)
	var i MonitorCheck
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Status,
		&i.ResponseTimeMs,
		&i.StatusCode,
		&i.ErrorMessage,
		&i.CheckedAt,
	)
	return i, err
}

const getMonitor = `-- name: GetMonitor :one
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMonitor(ctx context.Context, id int32) (Monitor, error) {
	row := q.db.QueryRow(ctx, getMonitor, id)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.IntervalSeconds,
		&i.TimeoutSeconds,
		&i.Status,
		&i.Headers,
		&i.Body,
		&i.ExpectedStatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMonitorByID = `-- name: GetMonitorByID :one
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetMonitorByIDParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) GetMonitorByID(ctx context.Context, arg GetMonitorByIDParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, getMonitorByID, arg.ID, arg.UserID)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.IntervalSeconds,
		&i.TimeoutSeconds,
		&i.Status,
		&i.Headers,
		&i.Body,
		&i.ExpectedStatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMonitorCheck = `-- name: GetMonitorCheck :one
SELECT id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
FROM monitor_checks
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetMonitorCheck(ctx context.Context, id int32) (MonitorCheck, error) {
	row := q.db.QueryRow(ctx, getMonitorCheck, id)
	var i MonitorCheck
	err := row.Scan(
		&i.ID,
		&i.MonitorID,
		&i.Status,
		&i.ResponseTimeMs,
		&i.StatusCode,
		&i.ErrorMessage,
		&i.CheckedAt,
	)
	return i, err
}

const getMonitorStats = `-- name: GetMonitorStats :one
SELECT
    COUNT(*) as total_checks,
    COUNT(CASE WHEN status = 'success' THEN 1 END) as successful_checks,
    COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed_checks,
    AVG(response_time_ms) as avg_response_time,
    MIN(response_time_ms) as min_response_time,
    MAX(response_time_ms) as max_response_time
FROM monitor_checks
WHERE monitor_id = $1
`

type GetMonitorStatsRow struct {
	TotalChecks      int64       `json:"total_checks"`
	SuccessfulChecks int64       `json:"successful_checks"`
	FailedChecks     int64       `json:"failed_checks"`
	AvgResponseTime  float64     `json:"avg_response_time"`
	MinResponseTime  interface{} `json:"min_response_time"`
	MaxResponseTime  interface{} `json:"max_response_time"`
}

func (q *Queries) GetMonitorStats(ctx context.Context, monitorID int32) (GetMonitorStatsRow, error) {
	row := q.db.QueryRow(ctx, getMonitorStats, monitorID)
	var i GetMonitorStatsRow
	err := row.Scan(
		&i.TotalChecks,
		&i.SuccessfulChecks,
		&i.FailedChecks,
		&i.AvgResponseTime,
		&i.MinResponseTime,
		&i.MaxResponseTime,
	)
	return i, err
}

const getMonitorUptime = `-- name: GetMonitorUptime :one
SELECT
    COUNT(CASE WHEN status = 'success' THEN 1 END)::float / COUNT(*)::float * 100 as uptime_percentage
FROM monitor_checks
WHERE monitor_id = $1
`

func (q *Queries) GetMonitorUptime(ctx context.Context, monitorID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getMonitorUptime, monitorID)
	var uptime_percentage int32
	err := row.Scan(&uptime_percentage)
	return uptime_percentage, err
}

const getMonitorUptimeByDateRange = `-- name: GetMonitorUptimeByDateRange :one
SELECT
    COUNT(CASE WHEN status = 'success' THEN 1 END)::float / COUNT(*)::float * 100 as uptime_percentage
FROM monitor_checks
WHERE monitor_id = $1
    AND checked_at >= $2
    AND checked_at <= $3
`

type GetMonitorUptimeByDateRangeParams struct {
	MonitorID   int32            `json:"monitor_id"`
	CheckedAt   pgtype.Timestamp `json:"checked_at"`
	CheckedAt_2 pgtype.Timestamp `json:"checked_at_2"`
}

func (q *Queries) GetMonitorUptimeByDateRange(ctx context.Context, arg GetMonitorUptimeByDateRangeParams) (int32, error) {
	row := q.db.QueryRow(ctx, getMonitorUptimeByDateRange, arg.MonitorID, arg.CheckedAt, arg.CheckedAt_2)
	var uptime_percentage int32
	err := row.Scan(&uptime_percentage)
	return uptime_percentage, err
}

const listActiveMonitors = `-- name: ListActiveMonitors :many
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
WHERE status = 'active'
ORDER BY created_at DESC
`

func (q *Queries) ListActiveMonitors(ctx context.Context) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listActiveMonitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monitor{}
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.IntervalSeconds,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Headers,
			&i.Body,
			&i.ExpectedStatusCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedMonitorChecks = `-- name: ListFailedMonitorChecks :many
SELECT id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
FROM monitor_checks
WHERE monitor_id = $1 AND status = 'failed'
ORDER BY checked_at DESC
LIMIT $2
`

type ListFailedMonitorChecksParams struct {
	MonitorID int32 `json:"monitor_id"`
	Limit     int32 `json:"limit"`
}

func (q *Queries) ListFailedMonitorChecks(ctx context.Context, arg ListFailedMonitorChecksParams) ([]MonitorCheck, error) {
	rows, err := q.db.Query(ctx, listFailedMonitorChecks, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonitorCheck{}
	for rows.Next() {
		var i MonitorCheck
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Status,
			&i.ResponseTimeMs,
			&i.StatusCode,
			&i.ErrorMessage,
			&i.CheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorChecks = `-- name: ListMonitorChecks :many
SELECT id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
FROM monitor_checks
WHERE monitor_id = $1
ORDER BY checked_at DESC
LIMIT $2 OFFSET $3
`

type ListMonitorChecksParams struct {
	MonitorID int32 `json:"monitor_id"`
	Limit     int32 `json:"limit"`
	Offset    int32 `json:"offset"`
}

func (q *Queries) ListMonitorChecks(ctx context.Context, arg ListMonitorChecksParams) ([]MonitorCheck, error) {
	rows, err := q.db.Query(ctx, listMonitorChecks, arg.MonitorID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonitorCheck{}
	for rows.Next() {
		var i MonitorCheck
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Status,
			&i.ResponseTimeMs,
			&i.StatusCode,
			&i.ErrorMessage,
			&i.CheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorChecksByDateRange = `-- name: ListMonitorChecksByDateRange :many
SELECT id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
FROM monitor_checks
WHERE monitor_id = $1
    AND checked_at >= $2
    AND checked_at <= $3
ORDER BY checked_at DESC
`

type ListMonitorChecksByDateRangeParams struct {
	MonitorID   int32            `json:"monitor_id"`
	CheckedAt   pgtype.Timestamp `json:"checked_at"`
	CheckedAt_2 pgtype.Timestamp `json:"checked_at_2"`
}

func (q *Queries) ListMonitorChecksByDateRange(ctx context.Context, arg ListMonitorChecksByDateRangeParams) ([]MonitorCheck, error) {
	rows, err := q.db.Query(ctx, listMonitorChecksByDateRange, arg.MonitorID, arg.CheckedAt, arg.CheckedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonitorCheck{}
	for rows.Next() {
		var i MonitorCheck
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Status,
			&i.ResponseTimeMs,
			&i.StatusCode,
			&i.ErrorMessage,
			&i.CheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitors = `-- name: ListMonitors :many
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
ORDER BY created_at DESC
`

func (q *Queries) ListMonitors(ctx context.Context) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monitor{}
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.IntervalSeconds,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Headers,
			&i.Body,
			&i.ExpectedStatusCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorsByStatus = `-- name: ListMonitorsByStatus :many
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
WHERE status = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMonitorsByStatus(ctx context.Context, status string) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitorsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monitor{}
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.IntervalSeconds,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Headers,
			&i.Body,
			&i.ExpectedStatusCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorsByUser = `-- name: ListMonitorsByUser :many
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
WHERE user_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListMonitorsByUser(ctx context.Context, userID int32) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitorsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monitor{}
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.IntervalSeconds,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Headers,
			&i.Body,
			&i.ExpectedStatusCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitorsByUserAndStatus = `-- name: ListMonitorsByUserAndStatus :many
SELECT id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
FROM monitors
WHERE user_id = $1 AND status = $2
ORDER BY created_at DESC
`

type ListMonitorsByUserAndStatusParams struct {
	UserID int32  `json:"user_id"`
	Status string `json:"status"`
}

func (q *Queries) ListMonitorsByUserAndStatus(ctx context.Context, arg ListMonitorsByUserAndStatusParams) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitorsByUserAndStatus, arg.UserID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monitor{}
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Url,
			&i.Method,
			&i.IntervalSeconds,
			&i.TimeoutSeconds,
			&i.Status,
			&i.Headers,
			&i.Body,
			&i.ExpectedStatusCode,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecentMonitorChecks = `-- name: ListRecentMonitorChecks :many
SELECT id, monitor_id, status, response_time_ms, status_code, error_message, checked_at
FROM monitor_checks
WHERE monitor_id = $1
ORDER BY checked_at DESC
LIMIT $2
`

type ListRecentMonitorChecksParams struct {
	MonitorID int32 `json:"monitor_id"`
	Limit     int32 `json:"limit"`
}

func (q *Queries) ListRecentMonitorChecks(ctx context.Context, arg ListRecentMonitorChecksParams) ([]MonitorCheck, error) {
	rows, err := q.db.Query(ctx, listRecentMonitorChecks, arg.MonitorID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MonitorCheck{}
	for rows.Next() {
		var i MonitorCheck
		if err := rows.Scan(
			&i.ID,
			&i.MonitorID,
			&i.Status,
			&i.ResponseTimeMs,
			&i.StatusCode,
			&i.ErrorMessage,
			&i.CheckedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monitorExists = `-- name: MonitorExists :one
SELECT EXISTS(SELECT 1 FROM monitors WHERE id = $1)
`

func (q *Queries) MonitorExists(ctx context.Context, id int32) (bool, error) {
	row := q.db.QueryRow(ctx, monitorExists, id)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const updateMonitor = `-- name: UpdateMonitor :one
UPDATE monitors
SET name = $2,
    url = $3,
    method = $4,
    interval_seconds = $5,
    timeout_seconds = $6,
    headers = $7,
    body = $8,
    expected_status_code = $9,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND user_id = $10
RETURNING id, user_id, name, url, method, interval_seconds, timeout_seconds, status, headers, body, expected_status_code, created_at, updated_at
`

type UpdateMonitorParams struct {
	ID                 int32       `json:"id"`
	Name               string      `json:"name"`
	Url                string      `json:"url"`
	Method             string      `json:"method"`
	IntervalSeconds    int32       `json:"interval_seconds"`
	TimeoutSeconds     int32       `json:"timeout_seconds"`
	Headers            []byte      `json:"headers"`
	Body               pgtype.Text `json:"body"`
	ExpectedStatusCode pgtype.Int4 `json:"expected_status_code"`
	UserID             int32       `json:"user_id"`
}

func (q *Queries) UpdateMonitor(ctx context.Context, arg UpdateMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, updateMonitor,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.Method,
		arg.IntervalSeconds,
		arg.TimeoutSeconds,
		arg.Headers,
		arg.Body,
		arg.ExpectedStatusCode,
		arg.UserID,
	)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Url,
		&i.Method,
		&i.IntervalSeconds,
		&i.TimeoutSeconds,
		&i.Status,
		&i.Headers,
		&i.Body,
		&i.ExpectedStatusCode,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMonitorStatus = `-- name: UpdateMonitorStatus :exec
UPDATE monitors
SET status = $2,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
`

type UpdateMonitorStatusParams struct {
	ID     int32  `json:"id"`
	Status string `json:"status"`
}

func (q *Queries) UpdateMonitorStatus(ctx context.Context, arg UpdateMonitorStatusParams) error {
	_, err := q.db.Exec(ctx, updateMonitorStatus, arg.ID, arg.Status)
	return err
}

const userOwnsMonitor = `-- name: UserOwnsMonitor :one
SELECT EXISTS(SELECT 1 FROM monitors WHERE id = $1 AND user_id = $2)
`

type UserOwnsMonitorParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

func (q *Queries) UserOwnsMonitor(ctx context.Context, arg UserOwnsMonitorParams) (bool, error) {
	row := q.db.QueryRow(ctx, userOwnsMonitor, arg.ID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
